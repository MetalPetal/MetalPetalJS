//
//  MTIVector+SIMD.m
//  MetalPetal
//
//  Created by Yu Ao on 2018/6/30.
//
//  Auto generated by generate-MTIVector+SIMD.sh

#import "MTIVector+SIMD.h"

@implementation MTIVector (SIMD)

+ (instancetype)vectorWithFloat2:(simd_float2)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float2));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float2)float2Value {
    simd_float2 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float2)) {
        memcpy(&value, self.bytes, sizeof(simd_float2));
    }
    return value;
}

+ (instancetype)vectorWithFloat3:(simd_float3)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float3));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float3)float3Value {
    simd_float3 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float3)) {
        memcpy(&value, self.bytes, sizeof(simd_float3));
    }
    return value;
}

+ (instancetype)vectorWithFloat4:(simd_float4)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float4));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float4)float4Value {
    simd_float4 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float4)) {
        memcpy(&value, self.bytes, sizeof(simd_float4));
    }
    return value;
}

+ (instancetype)vectorWithInt2:(simd_int2)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_int2));
    const int * valuePtr = (void *)&value;
    return [self vectorWithIntValues:valuePtr count:sizeof(value)/sizeof(int)];
}

- (simd_int2)int2Value {
    simd_int2 value = {0};
    if (self.scalarType == MTIVectorScalarTypeInt && self.byteLength == sizeof(simd_int2)) {
        memcpy(&value, self.bytes, sizeof(simd_int2));
    }
    return value;
}

+ (instancetype)vectorWithInt3:(simd_int3)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_int3));
    const int * valuePtr = (void *)&value;
    return [self vectorWithIntValues:valuePtr count:sizeof(value)/sizeof(int)];
}

- (simd_int3)int3Value {
    simd_int3 value = {0};
    if (self.scalarType == MTIVectorScalarTypeInt && self.byteLength == sizeof(simd_int3)) {
        memcpy(&value, self.bytes, sizeof(simd_int3));
    }
    return value;
}

+ (instancetype)vectorWithInt4:(simd_int4)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_int4));
    const int * valuePtr = (void *)&value;
    return [self vectorWithIntValues:valuePtr count:sizeof(value)/sizeof(int)];
}

- (simd_int4)int4Value {
    simd_int4 value = {0};
    if (self.scalarType == MTIVectorScalarTypeInt && self.byteLength == sizeof(simd_int4)) {
        memcpy(&value, self.bytes, sizeof(simd_int4));
    }
    return value;
}

+ (instancetype)vectorWithUInt2:(simd_uint2)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_uint2));
    const uint * valuePtr = (void *)&value;
    return [self vectorWithUIntValues:valuePtr count:sizeof(value)/sizeof(uint)];
}

- (simd_uint2)uint2Value {
    simd_uint2 value = {0};
    if (self.scalarType == MTIVectorScalarTypeUInt && self.byteLength == sizeof(simd_uint2)) {
        memcpy(&value, self.bytes, sizeof(simd_uint2));
    }
    return value;
}

+ (instancetype)vectorWithUInt3:(simd_uint3)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_uint3));
    const uint * valuePtr = (void *)&value;
    return [self vectorWithUIntValues:valuePtr count:sizeof(value)/sizeof(uint)];
}

- (simd_uint3)uint3Value {
    simd_uint3 value = {0};
    if (self.scalarType == MTIVectorScalarTypeUInt && self.byteLength == sizeof(simd_uint3)) {
        memcpy(&value, self.bytes, sizeof(simd_uint3));
    }
    return value;
}

+ (instancetype)vectorWithUInt4:(simd_uint4)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_uint4));
    const uint * valuePtr = (void *)&value;
    return [self vectorWithUIntValues:valuePtr count:sizeof(value)/sizeof(uint)];
}

- (simd_uint4)uint4Value {
    simd_uint4 value = {0};
    if (self.scalarType == MTIVectorScalarTypeUInt && self.byteLength == sizeof(simd_uint4)) {
        memcpy(&value, self.bytes, sizeof(simd_uint4));
    }
    return value;
}

+ (instancetype)vectorWithFloat2x2:(simd_float2x2)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float2x2));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float2x2)float2x2Value {
    simd_float2x2 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float2x2)) {
        memcpy(&value, self.bytes, sizeof(simd_float2x2));
    }
    return value;
}

+ (instancetype)vectorWithFloat2x3:(simd_float2x3)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float2x3));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float2x3)float2x3Value {
    simd_float2x3 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float2x3)) {
        memcpy(&value, self.bytes, sizeof(simd_float2x3));
    }
    return value;
}

+ (instancetype)vectorWithFloat2x4:(simd_float2x4)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float2x4));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float2x4)float2x4Value {
    simd_float2x4 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float2x4)) {
        memcpy(&value, self.bytes, sizeof(simd_float2x4));
    }
    return value;
}

+ (instancetype)vectorWithFloat3x2:(simd_float3x2)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float3x2));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float3x2)float3x2Value {
    simd_float3x2 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float3x2)) {
        memcpy(&value, self.bytes, sizeof(simd_float3x2));
    }
    return value;
}

+ (instancetype)vectorWithFloat3x3:(simd_float3x3)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float3x3));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float3x3)float3x3Value {
    simd_float3x3 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float3x3)) {
        memcpy(&value, self.bytes, sizeof(simd_float3x3));
    }
    return value;
}

+ (instancetype)vectorWithFloat3x4:(simd_float3x4)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float3x4));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float3x4)float3x4Value {
    simd_float3x4 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float3x4)) {
        memcpy(&value, self.bytes, sizeof(simd_float3x4));
    }
    return value;
}

+ (instancetype)vectorWithFloat4x2:(simd_float4x2)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float4x2));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float4x2)float4x2Value {
    simd_float4x2 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float4x2)) {
        memcpy(&value, self.bytes, sizeof(simd_float4x2));
    }
    return value;
}

+ (instancetype)vectorWithFloat4x3:(simd_float4x3)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float4x3));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float4x3)float4x3Value {
    simd_float4x3 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float4x3)) {
        memcpy(&value, self.bytes, sizeof(simd_float4x3));
    }
    return value;
}

+ (instancetype)vectorWithFloat4x4:(simd_float4x4)value {
    NSParameterAssert(sizeof(value) == sizeof(simd_float4x4));
    const float * valuePtr = (void *)&value;
    return [self vectorWithFloatValues:valuePtr count:sizeof(value)/sizeof(float)];
}

- (simd_float4x4)float4x4Value {
    simd_float4x4 value = {0};
    if (self.scalarType == MTIVectorScalarTypeFloat && self.byteLength == sizeof(simd_float4x4)) {
        memcpy(&value, self.bytes, sizeof(simd_float4x4));
    }
    return value;
}


@end
